.\" Automatically generated by Pandoc 2.17.1.1
.\"
.\" Define V font for inline verbatim, using C font in formats
.\" that render this, and otherwise B font.
.ie "\f[CB]x\f[]"x" \{\
. ftr V B
. ftr VI BI
. ftr VB B
. ftr VBI BI
.\}
.el \{\
. ftr V CR
. ftr VI CI
. ftr VB CB
. ftr VBI CBI
.\}
.TH "" "" "" "" ""
.hy
.SH rockpi_sata
.PP
Scripts for the Rockpi Quad SATA HAT using overlays for Raspberry Pi 4
.SS Which device?
.PP
This is the RockPi Quad SATA
HAT (https://wiki.radxa.com/Dual_Quad_SATA_HAT) that I\[cq]m using.
.SS Why?
.PP
Yes, why not just use the provided scripts from Radxa\[cq]s
Github (https://github.com/akgnah/rockpi-sata)?
.PP
My reasons for not being satisfied with the provided scripts are these(
in no particular order):
.PD 0
.P
.PD
* Many third party dependencies (pigpiod, python3-rpi.gpio,
python3-setuptools, python3-pip, python3-pil, python3-spidev, pigpio,
python3-pigpio, etc.)
which is fine for some but I don\[cq]t want them * Execution of shell
scripts through Python * Modifies my \f[V]/boot/config.txt\f[R] directly
* Very few comments in the scripts (yeah, yeah, I know good code
documents itself and all that jazz, but go ahead and read PEP8 and come
back to me) * Breaks if you disable IPv6 (which I do) * Poor portability
(only supports Raspbian and Ubuntu) * No console boot messages on the
OLED display * Not using the overlays for the display, gpio key and fan
* Can\[cq]t boot from a SATA device (the SATA interfaces are enabled
through a GPIO output in the script) * Can\[cq]t mount encrypted SATA
devices with key file without making sure that the scripts are executed
in proper order via systemd (which is a major pain point here)
.PP
This is a clunky first try to make something that is making heavy use of
the built-in capabilities in the boot loader via overlays.
.SS How does the Rockpi scripts work to initialise the hardware?
.PP
I\[cq]ll try to document my findings here and discuss what I\[cq]ve done
to work around them.
.SS GPIOs involved
.PP
There are a few GPIOs that we will need to address to get to grips with
some of the shortcomings of the HAT.
When started, the GPIOs to wake the SATA interfaces (25 for SATA1/2 and
26 for SATA 3/4) are set to inputs.
What that means is basically that the interface isn\[cq]t going to show
up until those GPIOs are set high via the Python scripts.
.PP
The SSD1306 OLED display has a reset on GPIO 23 which need to be tripped
in order to get the display to initialise itself.
.PP
The button can be read on GPIO 17.
.PP
The fan in the top board is connected to PWM1 on GPIO 13.
.PP
How do we address this?
Well, by using the \f[V]gpio\f[R] option in \f[V]/boot/config.txt\f[R],
using the \f[V]gpio-key\f[R] overlay and writing our own overlay for the
display and fan of course!
.PP
To reiterate, these are the GPIOs I will address first of all:
.PD 0
.P
.PD
| GPIO | Function | | \[em]- | \[em]\[em]\[em]\[em]- | | 13 | Top board
fan | | 17 | Button | | 23 | SSD1306 reset | | 25 | SATA 1/2 | | 26 |
SATA 3/4 |
.SS Fan
.PP
The fan can be enabled by the \f[V]pwm\f[R] overlay in
\f[V]/boot/config.txt\f[R]:
.IP
.nf
\f[C]
# Enable PWM channel on GPIO 13 (PWM1)
dtoverlay=pwm,pin=13,func=4
\f[R]
.fi
.PP
I also add a custom overlay (\f[V]pwm-fan\f[R]) which you can find in
the overlays folder.
Do note that you will have to build the kernel module too, which I am
doing by copying the \f[V]pwm-fan-0.0.1\f[R] directory to
\f[V]/usr/src\f[R] and adding it to dkms with
\f[V]dkms install pwm-fan/0.0.1\f[R] which will install the kernel
module for you automatically with every kernel update (you\[cq]ll need
the \f[V]linux-headers\f[R] package too).
The pwm-fan.c is copied from
\f[V]https://github.com/raspberrypi/linux/blob/rpi-5.10.y/drivers/hwmon/pwm-fan.c\f[R]
.PD 0
.P
.PD
This should really be made into a script that does this automatically in
a package.
.SS Button
.PP
In order to use the button, I\[cq]d like it to show up as a normal key
which I can read with a program (perhaps Python) via evdev.
.PD 0
.P
.PD
How?
Use the \f[V]gpio-key\f[R] overlay by adding the following into the
\f[V]/boot/config.txt\f[R]:
.IP
.nf
\f[C]
# Map the GPIO button to KEY_NEXT
dtoverlay=gpio-key,gpio=17,label=\[dq]Top board\[dq],keycode=0x197
\f[R]
.fi
.PP
Which will make it show up in \f[V]/dev/input/event0\f[R], for example:
.IP
.nf
\f[C]
$ evtest /dev/input/event0
Input driver version is 1.0.1
Input device ID: bus 0x19 vendor 0x1 product 0x1 version 0x100
Input device name: \[dq]button\[at]11\[dq]
Supported events:
  Event type 0 (EV_SYN)
  Event type 1 (EV_KEY)
    Event code 407 (KEY_NEXT)
Properties:
Testing ... (interrupt to exit)
Event: time 1615293751.744343, type 1 (EV_KEY), code 407 (KEY_NEXT), value 1
Event: time 1615293751.744343, -------------- SYN_REPORT ------------
Event: time 1615293751.844339, type 1 (EV_KEY), code 407 (KEY_NEXT), value 0
Event: time 1615293751.844339, -------------- SYN_REPORT ------------
\f[R]
.fi
.SS SSD1306 as framebuffer console
.PP
There is support to use the SSD1306 fitted to this device as a
framebuffer console.
To do that, you will have to make your own overlay as the current one
doesn\[cq]t include support for the reset functionality (see the Kernel
documentation (https://www.kernel.org/doc/Documentation/devicetree/bindings/display/ssd1307fb.txt)
and the current Raspberry Pi
overlay (https://github.com/raspberrypi/linux/blob/rpi-5.10.y/arch/arm/boot/dts/overlays/ssd1306-overlay.dts)),
thus we need to add that:
.IP
.nf
\f[C]
\&....
    target = <&i2c1>;
\&....
        reset-gpios = <&gpio 23 1>;
\&....
\f[R]
.fi
.PP
The above is in the ssd1306-overlay.dts file in the overlays folder in
this repository.
.PP
That file is built via the \f[V]build_dtbo.sh\f[R] script and put in the
\f[V]/boot/overlays\f[R] folder.
The following loads it (\f[V]/boot/config.txt\f[R]):
.IP
.nf
\f[C]
# Enable the SSD1306 display at boot
dtoverlay=ssd1306-overlay,width=128,height=32,inverted,sequential
\f[R]
.fi
.PP
And adding this to the end of the command line arguments adds the
framebuffer capabilites which will give a bunch of boot time messages on
the display (\f[V]/boot/cmdline.txt\f[R]) plus it disables the cursor:
.IP
.nf
\f[C]
fbcon=font:MINI4x6 fbcon=rotate:2 fbcon=logo-count:0 vt.global_cursor_default=0
\f[R]
.fi
.PP
Do note that I have the enclosure towards me (I can see the disk LEDs),
so you might have to modify the rotation of the framebuffer.
And I run it headless so there are no other framebuffers competing
Running this in the /etc/rc.local will change the virtual terminal to
no.
10 when booted (effectively clearing the screen)
.IP
.nf
\f[C]
chvt 10
\f[R]
.fi
.PP
It is very easy to print text if you can just echo to a tty, not so much
if you need to print to the framebuffer (unless you want to display
images), so the plan is to implement something printing on the different
tty\[cq]s (like disk status on one, CPU stuff on another etc)
.SS Starting the SATA interfaces at boot
.PP
In order to enable both the SATA interfaces at boot time, the following
is added to \f[V]/boot/config.txt\f[R]:
.IP
.nf
\f[C]
# For the Radxa Quad SATA Hat (26 = SATA1/2 25 = SATA3/4)
gpio=26=op,dh
gpio=25=op,dh
\f[R]
.fi
.PP
That sets the GPIOs as outputs and drives them high.
Don\[cq]t ask me why the 26 comes before the 25, if I didn\[cq]t do it
this way, the disks would come up in the wrong order (disk 3 as sda,
disk 1 as sdc etc.)
so it might be wrong in the documentation/wiki.
.SH Build a Debian package
.PP
If you want an installable package
\f[V]dpkg-buildpackage -b --no-sign\f[R] will do that for you
.SH What doesn\[cq]t work?
.PP
Well, this is just the early stages.
There are no scripts to do the functionality that you can get from the
Rockpi repository, but I am willing to accept PR\[cq]s if anyone is
tempted.
.PP
The Rockpi scripts loads the \f[V]w1-gpio\f[R] and \f[V]w1-therm\f[R]
kernel modules.
In the wiki there\[cq]s a reference to a couple of GPIOs which I
don\[cq]t know what they are for.
One is \f[V]GPIO4_C6\f[R] which would be GPIO 27 on the Pi and the other
one is \f[V]ADC_IN0\f[R] which is on GPIO 7.
The \f[V]w1-gpio\f[R] listens on GPIO 4 (Raspberry Pi pin 7) per
default, but that one isn\[cq]t used according to the wiki.
The Rockpi scripts are trying to read a 1-wire sensor
here (https://github.com/akgnah/rockpi-sata/blob/master/usr/bin/rockpi-sata/fan.py#L33).
So perhaps there\[cq]s a misconfiguration with the Rockpi scripts.
I will have to tear the enclosure down and have a look at the pins to
understand what\[cq]s connected where.
In the mean time, I\[cq]ll use the CPU temperature for fan control.
.SH Plans
.PP
Write the scrips needed for displaying information on the screen,
controlling what to do when the button is pressed and control the fan
speed.
The beauty of this is that is should be possible to write the scripts
without a lot of dependencies as most functionality is available as
files.
.PP
I\[cq]d like to make it possible to add this as a package for easy
maintainability ideally for Debian/Ubuntu, Arch Linux and Alpine.
